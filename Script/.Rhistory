skim(Ascensor)
Ascensor <- factor(Ascensor, labels = c("1", "0"))
summary(Ascensor)
hist(Ascensor)
prop.table(Ascensor)
rm(ascensor)
rm(Ascensor)
#Parqueadero
Parqueadero <- as.factor(DTRAIN$ascensorT)
class(Parqueadero)
Parqueadero <- factor(Parqueadero, labels = c("1", "0"))
summary(Parqueadero)
#Parqueadero
Parqueadero <- as.factor(DTRAIN$ascensorT)
class(Parqueadero)
Parqueadero <- factor(Parqueadero, labels = c("1", "0"))
summary(Parqueadero)
Parqueadero <- as.factor(DTRAIN$parqueaderoT)
class(Parqueadero)
Parqueadero <- factor(Parqueadero, labels = c("1", "0"))
summary(Parqueadero)
C:/Users/valer/Desktop/Andes/Intersemestral/Big Data/Comp6/
library(pacman)
# Cargar las librerías listadas e instalarlas en caso de ser necesario
p_load(tidyverse, # Manipular dataframes
rio, # Importar datos
stringr, # Manipular texto
stargazer, # Output de las regresiones
rgeos, # Calcular centroides
plotly, # Gráficos dinámicos
sf, # Leer/escribir/manipular datos espaciales
leaflet, # Visualizaciones dinámicas
tmaptools, # geocode_OSM()
osmdata) # Get OSM's data
setwd<- ("C:/Users/valer/Desktop/Andes/Intersemestral/Big Data/Comp6")
df <- import("arriendos_metro_cuadrado(2021-12-12).csv")
load("C:/Users/valer/Desktop/Andes/Intersemestral/Big Data/Comp6/arriendos_metro_cuadrado(2021-12-12).csv")
require(rio)
df <- import("arriendos_metro_cuadrado(2021-12-12).csv")
df <- import("arriendos_metro_cuadrado(2021-12-12).csv")
df <- import("Datos.csv")
setwd("C:/Users/valer/Desktop/Andes/Intersemestral/Big Data/Comp6")
df <- import("Datos.csv")
glimpse(df)
table(df$ciudad)
table(df$tipo_inmueble)
table(df$tipo_negocio)
filtro <- is.na(df$valor_administracion)
df$valor_administracion[filtro] <- 0
is.na(df$valor_administracion
is.na(df$valor_administracion)
df$valor_arriendo_total <- df$valor_arriendo + df$valor_administracion
df$valor_arriendo_total <- as.numeric(df$valor_arriendo_total)
summary(df$valor_arriendo_total) %>%
as.matrix() %>%
as.data.frame() %>%
mutate(V1 = scales::dollar(V1))
ggplot(df, aes(x = valor_arriendo_total)) +
geom_boxplot()+
scale_x_continuous(labels = scales::dollar)
# Existen muchos apartamentos que están en venta y tuvieron una mala marcación y por eso aparentemente se ven en arriendo, usaremos RegEx para eliminarlos
# Primero normalizaremos todo el texto
# Todo en minuscula
df$descripcion <- tolower(df$descripcion)
df$descripcion[0:5]
# Eliminamos tildes
df$descripcion <- iconv(df$descripcion, from = "UTF-8", to = "ASCII//TRANSLIT")
# Eliminamos caracteres especiales
df$descripcion <- str_replace_all(df$descripcion, "[^[:alnum:]]", " ")
# Eliminamos espacios extras
df$descripcion <- gsub("\\s+", " ", str_trim(df$descripcion))
# Encontramos todas las descripciones que tengan la palabra "venta" o "vender". Además que el valor del arriendo sea elevado
filtro1 <- grepl(" venta ", df$descripcion)
filtro2 <- grepl("vender", df$descripcion)
filtro <- filtro1 | filtro2
# Filtramos los datos. Se eliminan 329 observaciones
df <- df[!filtro,]
df <- df[!filtro,]
# El filtro anterior puede no ser perfecto entonces se eliminan todos los arriendos por encima de 50 millones
df <- df %>%
filter(valor_arriendo_total <= 50e6)
quantile(df$valor_arriendo_total,0.99)
# El filtro anterior puede no ser perfecto entonces se eliminan todos los arriendos por encima de 50 millones
df <- df %>%
filter(valor_arriendo_total <= 25e6)
ggplot(df, aes(x = valor_arriendo_total)) +
geom_boxplot()+
scale_x_continuous(labels = scales::dollar)
p <- ggplot(df, aes(x = valor_arriendo_total)) +
geom_histogram(fill = "darkblue", alpha = 0.4) +
labs(x = "Valor del arriendo (log-scale)", y = "Cantidad") +
scale_x_log10(labels = scales::dollar) +
theme_bw()
ggplotly(p)
m <- ggplot(df, aes(x = valor_arriendo_total)) +
geom_histogram(fill = "darkblue", alpha = 0.4) +
labs(x = "Valor del arriendo (log-scale)", y = "Cantidad") +
scale_x_continuous(labels = scales::dollar) +
theme_bw()
ggplotly(m)
df$amoblado <- grepl("amoblado", df$descripcion)
median(df$valor_arriendo_total[df$amoblado])
median(df$valor_arriendo_total[!df$amoblado])
ggplotly(p)
is.na(df$lat)| is.na(df$lon)
Filtro <- is.na(df$lat)| is.na(df$lon)
df <- df[!Filtro,]
limites <- gettext("Bogota Colombia")
limites
limites <- getbb("Bogota Colombia")
limites
filtroA <- between(df$lon, limites [1, "min"], limites[1, "max"])
filtroB <- between(df$lon, limites [2, "min"], limites[2, "max"])
fILTROab <- filtroA & filtroB
df <- df[!fILTROab]
FiltroAB <- filtroA & filtroB
df <- df[!FiltroAB,]
leaflet()%>%
addTiles() %>%
addCircles()%>%
addCircles(lng = df$lon
lat = df$lat)
leaflet()%>%
addTiles() %>%
addCircles()%>%
addCircles(lng = df$lon,
lat = df$lat)
leaflet()%>%
addTiles() %>%
addCircles()%>%
addCircles(lng = df$lon,
lat = df$lat)
table(df$estrato)
df$estrato[!(df$estrato %in% as.character(1:6))] = NA
color <- rep(NA, nrow(df))
# Para construir la paleta de colores vamos a usar esta bacanería de página web: https://coolors.co/
color[df$estrato == "1"] <- "#E76F51"
color[df$estrato == "2"] <- "#F4A261"
color[df$estrato == "3"] <- "#F4A261"
color[df$estrato == "4"] <- "#264653"
color[df$estrato == "5"] <- "#2A9D8F"
color[df$estrato == "6"] <- "#1A614C"
color[is.na(df$estrato)] <- "#B43718"
leaflet()%>%
addTiles() %>%
addCircles()%>%
addCircles(lng =  df$lon,
lat = df$lat,
color = color)
leaflet()%>%
addTiles() %>%
addCircles()%>%
addCircles(lng =  df$lon,
lat = df$lat,
color = color)
filtroA <- between(df$lon, limites [1, "min"], limites[1, "max"])
filtroB <- between(df$lat, limites [2, "min"], limites[2, "max"])
FiltroAB <- filtroA & filtroB
df <- df[!FiltroAB,]
leaflet()%>%
addTiles() %>%
addCircles()%>%
addCircles(lng = df$lon,
lat = df$lat)
leaflet()%>%
addTiles() %>%
addCircles()%>%
addCircles(lng =  df$lon,
lat = df$lat,
color = color)
# Calculamos el area máxima
df$area_maxima <- apply(df[, c("areac", "area")], 1, max)
df$mt2<- round(df$valor_arriendo_total/df$area_maxima,0)
summary(df$mt2)
df<- df[!(df$area_maxima==0),]
df$mt2<- round(df$valor_arriendo_total/df$area_maxima,0)
summary(df$mt2)
df<- df[!(df$area_maxima<12),]
df$mt2<- round(df$valor_arriendo_total/df$area_maxima,0)
summary(df$mt2)
df$area_maxima <- apply(df[, c("areac", "area")], 1, max)
df<- df[!(df$area_maxima<12),]
df$mt2<- round(df$valor_arriendo_total/df$area_maxima,0)
summary(df$mt2)
ggplot(df, aes(x= mt2))+
geom_histogram(fill = "darkblue", alpha = 0.4)
x<- df$mt2
x_std <- (x - min(x))/(max(x)-min(x))
leaflet()%>%
addTiles() %>%
addCircles()%>%
addCircles(lng =  df$lon,
lat = df$lat,
color = color,
radius = x_std)
max <- 70
min <- 1
x_scaled<- x_std*(max-min)+min
leaflet()%>%
addTiles() %>%
addCircles()%>%
addCircles(lng =  df$lon,
lat = df$lat,
color = color,
radius = x_std)
# Vamos a crear un mensaje en popup con html
html <- paste0("<b>Arriendo:</b> ",
scales::dollar(df$valor_arriendo_total),
"<br> <b>Area:</b> ",
as.integer(df$area_maxima), " mt2",
"<br> <b>Estrato:</b> ",
as.integer(df$estrato),
"<br> <b>Numero de alcobas:</b> ",
as.integer(df$rooms),
"<br> <b>Numero de baños:</b> ",
as.integer(df$bathrooms),
"<br> <b>Antiguedad:</b> ",
df$edad,
"<br> <b>Sector:</b> ",
df$sector,
"<br> <b>Barrio:</b> ",
df$neighborhood)
# Eliminamos los inmuebles con área menor a 20
filtroM <- df$area_maxima > 20
df <- df[filtroM, ]
# Calculamos valor del metro cuadrado en el arriendo
df$mt2 <- round(df$valor_arriendo_total/df$area_maxima, 0)
# Escalamos para que se pueda graficar
X <- df$mt2
# Veamos la distribución del valor del arriendo por mt2
p <- ggplot() +
geom_boxplot(aes(y = X), fill = "darkblue", alpha = 0.4) +
labs(y = "Valor del mt2 (log-scale)") +
scale_y_log10(labels = scales::number) +
scale_x_discrete() +
theme_bw()
ggplotly(p)
X_std <- (X - min(X))/(max(X) - min(X)) # Nuestra variable queda entre 0 y 1
max = 70
min = 1
X_scaled <- X_std * (max - min) + min # Escalamos entre 1 y 20
leaflet() %>%
addTiles() %>%
addCircles(lng = df$lon,
lat = df$lat,
col = color,
fillOpacity = 1,
opacity = 1,
radius = X_scaled,
popup = html)
available_tags("leisure")
parques <- opq(bbox = getbb("Bogota Colombia")) %>%
add_osm_feature(key = "leisure" , value = "park")
parques_sf <- osmdata_sf(parques)
parques_geometria <- parques_sf$osm_polygons %>%
select(osm_id, name)
# Calculamos el centroide de cada parque
centroides <- gCentroid(as(parques_geometria$geometry, "Spatial"), byid = T)
leaflet() %>%
addTiles() %>%
addPolygons(data = parques_geometria, col = "green",
opacity = 0.8, popup = parques_geometria$name) %>%
addCircles(lng = centroides$x,
lat = centroides$y,
col = "red", opacity = 1, radius = 1)
centroides <- gCentroid(as(parques_geometria$geometry, "Spatial"), byid = T)
leaflet() %>%
addTiles() %>%
addPolygons(data = parques_geometria, col = "green",
opacity = 0.8, popup = parques_geometria$name) %>%
addCircles(lng = centroides$x,
lat = centroides$y,
col = "red", opacity = 1, radius = 1)
# Ahora vamos a calcular la distancia de cada apartamento al centroide de cada parque
df_sf <- st_as_sf(df, coords = c("lon", "lat"))
st_crs(df_sf) <- 4326
centroides_sf <- st_as_sf(centroides, coords = c("x", "y"))
dist_matrix <- st_distance(x = df_sf, y = centroides_sf)
# Encontramos la distancia mínima a un parque
dist_min <- apply(dist_matrix, 1, min)
df$distancia_parque <- dist_min
p <- ggplot(df, aes(x = distancia_parque)) +
geom_histogram(bins = 50, fill = "darkblue", alpha = 0.4) +
labs(x = "Distancia mínima a un parque en metros", y = "Cantidad",
title = "Distribución de la distancia a los parques") +
theme_bw()
ggplotly(p)
leaflet() %>%
addTiles() %>%
addPolygons(data = parques_geometria, col = "green",
opacity = 0.8, popup = parques_geometria$name) %>%
addCircles(lng = centroides$x,
lat = centroides$y,
col = "red", opacity = 1, radius = 1)
f <- ggplot(df, aes(x = distancia_parque, y = valor_arriendo_total)) +
geom_point(col = "darkblue", alpha = 0.4) +
labs(x = "Distancia mínima a un parque en metros (log-scale)",
y = "Valor del arriendo (log-scale)",
title = "Relación entre la proximidad a un parque y el valor del arriendo") +
scale_x_log10() +
scale_y_log10(labels = scales::dollar) +
theme_bw()
ggplotly(f)
library(pacman) #Llamar librería#Se cargan las librerías a usar en el presente Problem Set
library(pacman) #Llamar librería#Se cargan las librerías a usar en el presente Problem Set
p_load(caret,
Matrix,
recipes,
rio, #Instalar librerías que falten
tidyverse,
glmnet,
dplyr,
readr,
gamlr,
tidymodels,
ggplot2,
scales,
ggpubr,
skimr,
rvest,
caret,
stringr,
boot,
caret,
modeest,
recipes,
glmnet,
stargazer,
pROC,
sf,
leaflet,
tmaptools,
class,
nngeo,
osmdata)
rm(list = ls()) #Limpia las variables que existan al momento de correr el código
###Base de datos Problem set 2
library(readr)
#Se debe poner el directorio de donde está el script:
#Session-> Set Working directory -> To source file location, para lo cual se debe descargar el repositorio DTEST<-data.frame(readRDS("../Elementos_Guardados/test.rds" #Guardar las bases de datos
DTEST<-data.frame(readRDS("../Elementos_Guardados/test.rds"))  #Guardar las bases de datos
setwd("C:/Users/valer/Desktop/Andes/Intersemestral/Big Data/ArchivoPS3/Problem-Set-3/Script")
#Se debe poner el directorio de donde está el script:
#Session-> Set Working directory -> To source file location, para lo cual se debe descargar el repositorio DTEST<-data.frame(readRDS("../Elementos_Guardados/test.rds" #Guardar las bases de datos
DTEST<-data.frame(readRDS("../Elementos_Guardados/test.rds"))  #Guardar las bases de datos
DTRAIN <- data.frame(readRDS("../Elementos_Guardados/train.rds"))
#Se ponen en minúscula los caracteres de description y title en la base train
DTRAIN$description<-str_to_lower(string=DTRAIN$description)
DTRAIN$title<-str_to_lower(string=DTRAIN$title)
#Se ponen en minúscula los caracteres de description y title en la base test
DTEST$description<-str_to_lower(string=DTEST$description)
DTEST$title<-str_to_lower(string=DTEST$title)
# Se eliminan las tildes
DTRAIN$description <- iconv(DTRAIN$description, from = "UTF-8", to = "ASCII//TRANSLIT")
DTEST$description <- iconv(DTEST$description, from = "UTF-8", to = "ASCII//TRANSLIT")
# Se eliminan caracteres especiales
DTRAIN$description <- str_replace_all(DTRAIN$description, "[^[:alnum:]]", " ")
DTEST$description <- str_replace_all(DTEST$description, "[^[:alnum:]]", " ")
# Se eliminan espacios extras
DTRAIN$description <- gsub("\\s+", " ", str_trim(DTRAIN$description))
DTEST$description <- gsub("\\s+", " ", str_trim(DTEST$description))
#En esta sección se unen la base Train y test para realizar la limpieza de datos
train<- DTRAIN %>% mutate(base = "train")
test <- DTEST %>% mutate(base="test")
HOUSE<- bind_rows(train,test) %>% st_as_sf(coords=c("lon","lat"),crs=4326)
leaflet() %>% addTiles() %>% addCircles(data = HOUSE)
str(HOUSE)
Polchapinero <- getbb(place_name = "UPZ Chapinero, Bogota",
featuretype = "boundary:administrative",
format_out = "sf_polygon") %>% .$multipolygon
leaflet() %>% addTiles() %>% addPolygons(data= Polchapinero, col = "red")
st_crs(HOUSE)
st_crs(Polchapinero)
Polchapinero <- st_transform(Polchapinero, st_crs(HOUSE))
House_Chapinero<- HOUSE[Polchapinero,]
leaflet() %>% addTiles() %>% addCircles(data = House_Chapinero, color = "red" ) %>% addPolygons(data= Polchapinero, col = "blue")
available_features()
available_tags("amenity")
mnzBog<-readRDS("../Elementos_Guardados/Bogota.rds") #Datos de manzanas Bogotá
sf_use_s2(FALSE)
mnzBogota<-subset(mnzBog, select=c("MANZ_CCNCT", "geometry"))
mnz_chap <- mnzBogota[Polchapinero,]
leaflet() %>% addTiles() %>% addCircles(data = House_Chapinero, color = "red" ) %>% addPolygons(data= mnz_chap, col = "blue")
house_chapinero_mnz <- st_join(House_Chapinero, mnz_chap)
colnames(house_chapinero_mnz)
table(is.na(house_chapinero_mnz$MANZ_CCNCT))
db_1 <- house_chapinero_mnz %>% subset(is.na(MANZ_CCNCT)==F)
db_2 <- house_chapinero_mnz %>% subset(is.na(MANZ_CCNCT)==T) %>% mutate(MANZ_CCNCT = NULL)
leaflet() %>% addTiles() %>% addPolygons(data=db_2[1,] %>% st_buffer(dist = 0.0005))
db_2 <- st_join(st_buffer(db_2, dist = 0.0005), mnzBogota)%>% subset(duplicated(property_id)==F)
filtro<-is.na(house_chapinero_mnz$MANZ_CCNCT)
house_chapinero_mnz$MANZ_CCNCT[filtro]<-db_2$MANZ_CCNCT
table(is.na(house_chapinero_mnz$MANZ_CCNCT))
house_chapinero_mnz <-  house_chapinero_mnz %>%
group_by(MANZ_CCNCT) %>%
mutate(new_surface_2=median(surface_total,na.rm=T))
table(is.na( house_chapinero_mnz$new_surface_2))
house_buf_Bog <- st_buffer(house_chapinero_mnz,dist=0.005)
leaflet() %>% addTiles() %>% addPolygons(data=house_buf_Bog , color="red") %>% addCircles(data=house_chapinero_mnz)
house_buf_Bog<- st_join(house_buf_Bog,house_chapinero_mnz[,"surface_total"])
st_geometry(house_buf_Bog) = NULL
house_buf_mean_Bog <-house_buf_Bog %>% group_by(property_id) %>% summarise(surface_new_3=mean(surface_total.y,na.rm=T))
house_chapinero_mnz<- left_join(house_chapinero_mnz,house_buf_mean_Bog,"property_id")
table(is.na( house_chapinero_mnz$new_surface_2))
table(is.na( house_chapinero_mnz$surface_new_3))
rm(house_buf_Bog, house_buf_mean_Bog)
#Para Medellín
PolPoblado <- getbb(place_name = "Comuna 14 - El Poblado, Medellín",
featuretype = "boundary:administrative",
format_out = "sf_polygon")
leaflet() %>% addTiles() %>% addPolygons(data= PolPoblado, col = "red")
PolPoblado <- st_transform(PolPoblado, st_crs(HOUSE))
House_Poblado<- HOUSE[PolPoblado,]
available_features()
available_tags("amenity")
mnzAnt<-readRDS("../Elementos_Guardados/Antioquia.rds") #Datos de manzanas Antioquia
sf_use_s2(FALSE)
mnzMedellin<-subset(mnzAnt, select=c("MANZ_CCNCT", "geometry"))
mnz_pob <- mnzMedellin[PolPoblado,]
leaflet() %>% addTiles() %>% addCircles(data = House_Poblado, color = "red" ) %>% addPolygons(data= mnz_pob, col = "blue")
house_pob_mnz <- st_join(House_Poblado, mnz_pob)
colnames(house_pob_mnz)
table(is.na(house_pob_mnz$MANZ_CCNCT))
db_1M <- house_pob_mnz %>% subset(is.na(MANZ_CCNCT)==F)
db_2M<- house_pob_mnz %>% subset(is.na(MANZ_CCNCT)==T) %>% mutate(MANZ_CCNCT = NULL)
leaflet() %>% addTiles() %>% addPolygons(data=db_2M[1,] %>% st_buffer(dist = 0.0005))
db_2M <- st_join(st_buffer(db_2M, dist = 0.0009), mnzMedellin)%>% subset(duplicated(property_id)==F)
table(is.na(db_2M$MANZ_CCNCT))
filtro_Med<-is.na(house_pob_mnz$MANZ_CCNCT)
house_pob_mnz$MANZ_CCNCT[filtro_Med]<-db_2M$MANZ_CCNCT
table(is.na(house_pob_mnz$MANZ_CCNCT))
house_pob_mnz <-  house_pob_mnz %>%
group_by(MANZ_CCNCT) %>%
mutate(new_surface_2=median(surface_total,na.rm=T))
table(is.na( house_pob_mnz$new_surface_2))
house_buf_Med <- st_buffer(house_pob_mnz,dist=0.01)
leaflet() %>% addTiles() %>% addPolygons(data=house_buf_Med , color="red") %>% addCircles(data=house_pob_mnz)
house_buf_Med<- st_join(house_buf_Med,house_pob_mnz[,"surface_total"])
st_geometry(house_buf_Med) = NULL
house_buf_mean_Med <-house_buf_Med %>% group_by(property_id) %>% summarise(surface_new_3=mean(surface_total.y,na.rm=T))
house_pob_mnz<- left_join(house_pob_mnz,house_buf_mean_Med ,"property_id")
table(is.na( house_pob_mnz$new_surface_2))
table(is.na( house_pob_mnz$surface_new_3))
table(is.na( house_pob_mnz$new_surface_2))
table(is.na( house_pob_mnz$surface_new_3))
summary(house_pob_mnz)
View(House_Chapinero)
table(is.na( house_chapinero_mnz$surface_new_3))
View(house_chapinero_mnz)
View(house_chapinero_mnz)
HOUSEOF<- rbind.data.frame(house_pob_mnz, house_chapinero_mnz)
View(HOUSEOF)
#CREACIÓN VARIABLES POR MEDIO DE DESCRIPCIÓN PARA BASE DE DATOS
Descripc<-HOUSEOF$description
view(HOUSEOF)
table(is.na( HOUSEOF$surface_new_3))
table(HOUSEOF$base)
table(is.na( HOUSEOF$surface_new_3))
table(HOUSEOF$base)
table(is.na( house_pob_mnz$surface_new_3))
rm(list = ls()) #Limpia las variables que existan al momento de correr el código
DTEST<-data.frame(readRDS("../Elementos_Guardados/test.rds"))  #Guardar las bases de datos
DTRAIN <- data.frame(readRDS("../Elementos_Guardados/train.rds"))
#Se ponen en minúscula los caracteres de description y title en la base train
DTRAIN$description<-str_to_lower(string=DTRAIN$description)
DTRAIN$title<-str_to_lower(string=DTRAIN$title)
#Se ponen en minúscula los caracteres de description y title en la base test
DTEST$description<-str_to_lower(string=DTEST$description)
DTEST$title<-str_to_lower(string=DTEST$title)
# Se eliminan las tildes
DTRAIN$description <- iconv(DTRAIN$description, from = "UTF-8", to = "ASCII//TRANSLIT")
DTEST$description <- iconv(DTEST$description, from = "UTF-8", to = "ASCII//TRANSLIT")
# Se eliminan caracteres especiales
DTRAIN$description <- str_replace_all(DTRAIN$description, "[^[:alnum:]]", " ")
DTEST$description <- str_replace_all(DTEST$description, "[^[:alnum:]]", " ")
# Se eliminan espacios extras
DTRAIN$description <- gsub("\\s+", " ", str_trim(DTRAIN$description))
DTEST$description <- gsub("\\s+", " ", str_trim(DTEST$description))
#En esta sección se unen la base Train y test para realizar la limpieza de datos
train<- DTRAIN %>% mutate(base = "train")
test <- DTEST %>% mutate(base="test")
HOUSE<- bind_rows(train,test) %>% st_as_sf(coords=c("lon","lat"),crs=4326)
Polchapinero <- getbb(place_name = "UPZ Chapinero, Bogota",
featuretype = "boundary:administrative",
format_out = "sf_polygon") %>% .$multipolygon
Polchapinero <- st_transform(Polchapinero, st_crs(HOUSE))
class(HOUSE)
st_crs(HOUSE)
st_crs(Polchapinero)
####
mnzBog<-readRDS("../Elementos_Guardados/Bogota.rds") #Datos de manzanas Bogotá
sf_use_s2(FALSE)
mnzBogota<-subset(mnzBog, select=c("MANZ_CCNCT", "geometry"))
HOUSE_Bog<- HOUSE[HOUSE$l3=="Bogotá D.C",]
HOUSE_Med<- HOUSE[HOUSE$l3=="Medellín",]
House_BOG_mnz<- st_join(HOUSE_Bog, mnzBogota)
table(is.na(House_BOG_mnz$MANZ_CCNCT))
db_1 <- House_BOG_mnz %>% subset(is.na(MANZ_CCNCT)==F)
db_2 <- House_BOG_mnz %>% subset(is.na(MANZ_CCNCT)==T) %>% mutate(MANZ_CCNCT = NULL)
leaflet() %>% addTiles() %>% addPolygons(data=db_2[1,] %>% st_buffer(dist = 0.0005))
db_2 <- st_join(st_buffer(db_2, dist = 0.0005), mnzBogota)%>% subset(duplicated(property_id)==F)
filtro<-is.na(House_BOG_mnz$MANZ_CCNCT)
House_BOG_mnz$MANZ_CCNCT[filtro]<-db_2$MANZ_CCNCT
table(is.na(House_BOG_mnz$MANZ_CCNCT))
House_BOG_mnz <-  House_BOG_mnz %>%
group_by(MANZ_CCNCT) %>%
mutate(new_surface_2=median(surface_total,na.rm=T))
table(is.na( House_BOG_mnz$new_surface_2))
house_buf_Bog <- st_buffer(House_BOG_mnz,dist=0.005)
leaflet() %>% addTiles() %>% addPolygons(data=house_buf_Bog , color="red") %>% addCircles(data=House_BOG_mnz)
house_buf_Bog<- st_join(house_buf_Bog,House_BOG_mnz[,"surface_total"])
gc()
